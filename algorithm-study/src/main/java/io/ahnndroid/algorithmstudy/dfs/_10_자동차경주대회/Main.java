package io.ahnndroid.algorithmstudy.dfs._10_자동차경주대회;

/**
 * 
[ 문제 설명 ]
전국 자동차 경주 대회가 매년 열리고 있다.
이 대회에서는 출발지점부터 도착지점까지 거리가 워낙 멀기 때문에 
경주 도중에 각 자동차는 정비소를 방문하여 정비를 받아야 한다. 
정비소들은 출발지점에서 도착지점으로 가는 길가에 있으며 ①번부터 차례로 번호가 붙어 있다.
 
이 대회에서는 참가하는 선수의 안전을 위하여 
정비를 받지 않고 미리 정한 거리를 초과하여 갈 수 없도록 규칙을 정하였다. 
그리고 정비소마다 정비하는데 걸리는 정비 시간이 서로 다를 수 있다.
 
정비소에서 정비하는데 걸리는 시간을 가장 적게 하려고 할 때 
최소 총 정비시간을 구하는 프로그램을 작성하시오.
 
예를 들어 정비소가 5개 있고, 한 번 정비를 받고 최대 140㎞를 갈 수 있는 경우를 생각해 보자. 
출발지점에서 정비소 ①까지의 거리가 100㎞이고, 
정비소 ①을 방문하여 정비할 때 걸리는 시간은 5분이다.
 
자동차가 출발지점에서 대회 규칙을 지키면서 
정비소 ①, ③, ⑤를 차례대로 방문하여 도착지점까지 갈 수 있고, 
정비소 ②, ④를 방문하여 갈 수도 있다. 
정비소 ①, ③, ⑤를 방문하는 경우에는 16분(=5+4+7분)이 걸리는데, 
이것은 정비소 ②, ④를 방문하여 걸리는 21분(=10+11분)보다 총 정비 시간이 적게 걸린다.


[ 입력 ]
입력 시 첫째 줄에는 정비를 받지 않고 갈 수 있는 최대 거리가 주어진다.
둘째 줄에는 정비소의 개수가 입력되는데 정비소 수는 50개 이하이다.
셋째 줄에는 인접한 정비소 사이의 거리가 차례로 주어진다.
넷째 줄에는 정비소 별 정비 시간이 차례로 주어진다.
모든 입력은 양의 정수이다.


[ 출력 ]
첫째 줄에 정비소에서 정비하는데 걸리는 총 정비 시간을 출력한다.
정비소를 전혀 방문하지 않아도 되는 경우에 총 정비 시간을 0으로 출력한다.


[ 입력 예시 ]
140
5
100 30 100 40 50 60
5 10 4 11 7


[ 출력 예시 ]
16

 * 
 * @author ahnndroid
 *
 */
import java.util.Scanner;

public class Main {
	
	// 정비를 받지 않고 갈 수 있는 최대 거리
	static int K;
	
	// 정비소의 개수
	static int N;
	
	// 정비소 간 거리를 담을 배열
	static int[] L;
	
	// 정비소 별 정비 시간을 담을 배열
	static int[] T;
	
	// 최소 총 정비 시간 결과를 담게 될 전역 변수 
	static int sol = 0x7fffffff;
	
	
	/**
	 * 전역 변수 입력 및 초기화
	 */
	static void init() {
		
		L = new int[50 + 10];
		T = new int[50 + 10];
		
		Scanner sc = new Scanner(System.in);
		
		// 정비를 받지 않고 갈 수 있는 최대 거리를 입력 받아 초기화
		K = sc.nextInt();
		
		// 정비소 개수를 입력 받아 초기화
		N = sc.nextInt();
		
		// 정비소 간 거리를 입력 받아 배열 초기화
		for (int i = 0; i <= N; i++) {
			L[i] = sc.nextInt();
		}
		
		// 정비소 별 정비 시간을 입력 받아 배열 초기화
		for (int i = 1; i <= N; i++) {
			T[i] = sc.nextInt();
		}
		
		sc.close();
	}
	
	/**
	 * 해를 구하기 위한 깊이 우선 탐색 진행
	 * 
	 * @param pos : 정비할 순번의 정비소 번호
	 * @param dist : pos 지점까지 정비 안 하고 온 거리
	 * @param cost : pos 지점 이전까지의 정비 시간
	 */
	static void DFS(int pos, int dist, int cost) {
		
		// 가지 치기 : 정비 시간이 sol에 기록된 값보다 크거나 같은 경우 리턴
		if (cost >= sol) return;
		
		// 1) 종료 조건
		//    => 탐색 범위를 벗어나는 경우, sol에 현재까지의 cost를 업데이트 후 리턴
		if (pos == N + 1) {
			if (cost < sol) sol = cost;
			return;
		}
		
		// 2) 최소 정비 비용을 찾기 위한 재귀 탐색 진행
		// 2-1) 정비하는 경우 
		DFS(pos + 1, L[pos], cost + T[pos]);
		
		// 가지 치기 : pos 지점까지 정비 안 하고 온 거리와 다음 정비소까지의 거리가 최대 거리보다 크다면 탐색할 필요 없으므로 쳐냄.
		if (dist + L[pos] <= K) {
			// 2-2) 정비하지 않는 경우
			DFS(pos + 1, dist + L[pos], cost);
		}		
		
	}
	
	/**
	 * 최종 결과 출력
	 */
	static void print() {
		System.out.println(sol);
	}

	public static void main(String[] args) {
		
		init();				// 전역 변수 초기화 진행
		
		DFS(1, L[0], 0);	// 해를 구하기 위한 깊이 우선 탐색 진행
		
		print();			// 최종 결과 출력
	}

}
